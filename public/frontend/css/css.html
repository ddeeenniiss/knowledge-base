<div class="block">
  <div class="container site-border">
    <h3>box-sizing: border-box;</h3>
    <p>Content + Padding + Border sind gemeinsam die width</p>
    <h3>content-box:</h3>
    <p>Nur Inhalt ist width, padding und border zählen exklusiv zusätzlich</p>

    <h3>Scrollbalken Breite managen in Navigation</h3>
    <p>scrollbar-gutter: stable;</p>
    <p>
      Sorgt dafür, dass die Scrollbar-Breite in der Navigation nicht den Inhalt
      verschiebt.
    </p>

    <!-- Bereich, um CSS zu zeigen -->
    <pre class="css-output" style="display: none"></pre>

    <p>
      Wichtig: Es muss immer einen Änderungszustand geben, bsp hover, click!
      transition: property duration timing-function delay; property: zB
      transform, all duration: wie lange dauert die Transition, zB 2s
      timing-function: linear konstante Geschwindigkeit cubic-bezier(0, 0, 1, 1)
      ease (default) langsam → schnell → langsam cubic-bezier(0.25, 0.1, 0.25,
      1) ease-in startet langsam ease-in = cubic-bezier(0.42, 0, 1, 1) ease-out
      endet langsam ease-out = cubic-bezier(0, 0, 0.58, 1) ease-in-out langsam
      rein und raus = ease-in-out = cubic-bezier(0.42, 0, 0.58, 1) step-start
      sofortiger Sprung step-end Sprung am Ende: Für hover empfohlen:
      cubic-bezier(0.4, 0, 0.2, 1) cubic-bezier: (x1, y1, x2, y2) Eine
      Timing-Function beschreibt nicht die Bewegung im Raum, sondern: Wie
      schnell der Fortschritt der Animation über die Zeit passiert x-Achse →
      Zeit (0 → 1) y-Achse → Fortschritt der Animation (0 → 1) Startpunkt ist
      immer (0,0) Endpunkt ist immer (1,1) Beispiel: cubic-bezier(0.25, 0.1,
      0.25, 1) x1 = 0.25 bedeutet sehr früher Einfluss der Geschwindigkeit
    </p>
    <img
      width="287"
      height="301"
      alt="image"
      src="https://github.com/user-attachments/assets/f5f246d0-f14e-4a64-b8fb-218176019287"
    />
    <h4>
      Wie lässt sich der Effekt direkt beim neuladen einer Seite animieren?
    </h4>
    <div class="card">
      #myDiv { transform: rotateZ(0deg); animation: flip 3s ease infinite; }
      @keyframes flip { to { transform: rotateZ(360deg); } }
    </div>

    <!-- Beispiel Filter Blur mit Hover-Effekt -->
    <h3>filter: blur(px)</h3>
    <p>
      macht Element unscharf. Bereits kleine Werte bis 10px sind ausreichend.
    </p>

    <!-- Beispiel Filter Brightness mit Hover-Effekt -->
    <h3>filter: brightness()</h3>
    <p>
      verändert Helligkeit des Elements. 0% = schwarz, 100% = Original, >100% =
      heller.
    </p>

    <!-- Beispiel Filter Grayscale mit Hover-Effekt -->
    <h3>filter: grayscale()</h3>
    <p>
      macht Element in Graustufen. 100% = vollständig grau, 0% = Originalfarbe.
    </p>

    <!-- Flexbox Erklärung -->
    <h3>display: flex</h3>
    <p>
      macht Container zu flexiblen Boxen. Elemente darin können flexibel
      angeordnet werden.
    </p>
    <a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/"
      >Link zur Flexbox Dokumentation</a
    >

    <h2>Pseudo-Elemente</h2>
    <h3>::before und ::after</h3>
    <p>
      ::before und ::after ermöglichen das Einfügen von Inhalten vor oder nach
      dem Inhalt eines Elements. Sie werden oft für dekorative Zwecke oder
      zusätzliche Informationen verwendet, ohne das HTML zu verändern.
    </p>
    <pre><code>.element::before {
  content: "Vor dem Inhalt";
  color: blue;
}
.element::after {
  content: "Nach dem Inhalt";
  color: red;
}
</code></pre>
    <h3>::backdrop</h3>
    <p>
      ::backdrop ist ein Pseudo-Element, das auf das Hintergrund-Element eines
      Modals oder Popups angewendet wird. zB Hintergrund verdunkeln hinter
      Popup.
    </p>
    <pre><code>.modal::backdrop {
  background-color: rgba(0, 0, 0, 0.5);
}
</code></pre>
    <!-- Nochmal Funktion anschauen wie es funktioniert -->
    <div class="card">
      <div class="box">
        <button id="openDialog">OPEN DIALOG</button>
      </div>
    </div>

    <div class="dialog-container">
      <dialog id="dialog">
        <h2>Dialog Fenster geöffnet</h2>
        <p>
          ::backdrop Pseudoelement beeinflusst den Hintergrund des dialog
          Elements
        </p>
        <button class="button--q" id="closeDialog">CLOSE DIALOG</button>
      </dialog>
    </div>

    <h2>Pseudo-Klassen</h2>
    <h3>:hover</h3>
    <p>
      :hover ist ein Pseudo-Klassen-Selektor, der angewendet wird, wenn der
      Benutzer den Mauszeiger über ein Element bewegt.
    </p>
    <pre><code>.element:hover {
  background-color: yellow;
}
</code></pre>
    <h3>:focus</h3>
    <p>
      :focus ist ein Pseudo-Klassen-Selektor, der angewendet wird, wenn ein
      Element den Fokus erhält, z.B. durch Klicken oder Tabben.
    </p>
    <pre><code>.element:focus {
  outline: 2px solid blue;
}
</code></pre>
    <h3>:focus-visible</h3>
    <p>
      :focus-visible ist ein Pseudo-Klassen-Selektor, der angewendet wird, wenn
      ein Element den Fokus erhält und der Fokus sichtbar ist (z.B. durch
      Tastatur-Navigation).
    </p>
    <pre><code>.element:focus-visible {
  outline: 2px solid blue;
}
</code></pre>
    <h3>:active</h3>
    <p>
      :active ist ein Pseudo-Klassen-Selektor, der angewendet wird, wenn ein
      Element aktiv ist, z.B. beim gedrückten Klick, .
    </p>
    <pre><code>.element:active {
  background-color: green;
}
</code></pre>
    <h3>:checked</h3>
    <p>
      :checked ist ein Pseudo-Klassen-Selektor, der angewendet wird, wenn ein
      Element (z.B. ein Checkbox oder Radio Button) aktiviert ist.
    </p>
    <pre><code>.checkbox:checked + .label {
  font-weight: bold;
}
</code></pre>

    <h2>Listenelemente</h2>
    <h3>list-style-position</h3>
    <p>
      Bei ul Listen kann mit list-style-position: inside; der Listenpunkt an
      derselben Linie wie Text angelegt werden.
    </p>
    <p>
      mit list-style-position: outside; wird der Listenpunkt außerhalb des
      Textstarts angelegt
    </p>
    <ul>
      <li class="list-style-position--inside">Inside</li>
      <li class="list-style-position--outside">Outside</li>
    </ul>
  </div>
</div>
